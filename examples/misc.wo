import core

#: Int -> Int
let fac n = do
    if n == 0 then
        1
    else
        n - 1 |> fac |> (*) n
    end
end

let fib n = do
    # The recursive version is
    # ridiculously slow!
    var x = 0
    var y = 1
    var z = 0
    for 0 n fn |_| do
        z = x + y
        x = y
        y = z
    end
    x
end

let isPrime n = do
    let l = n / 2 + 1
    var prime = true
    var i = 2
    while i != l do
        if n % i == 0 then
            prime = false 
            break
        end
        i = i + 1 
    end
    prime
end

let counter init = do
    var i = init
    fn |inc| do
        i = i ? "old i" + inc ? "new i"
    end
end

let counter_ = do
    var i = 0
    fn |inc| do
        i = i ? "old i" + inc ? "new i"
    end
end

# block expression, sequence of instructions;
# should end in a Compute(Expr) instruction
# NOTE: a block expression is different from a
# fn || -> T do ... end as the former immediatly
# reduces to an expression of the form T, but the latter
# is a T -> T that only reduces to a T when applied to ()
let hundredEvenNumbers = do
    # var-instruction
    var result = 0
    # Loops are not expressions, as you cannot
    # define them in a top-level let-instruction
    # because there are no global variables.
    for 0 100 fn |i| do
        if i % 2 == 0 then
            # assignment-instruction
            result = result + i
        end
    end
    result
end

let fizzBuzz n ~ do
    if n % 15 == 0 then
        @dump "FizzBuzz"
    elif n % 3 == 0 then
        @dump "Fizz"
    elif n % 5 == 0 then
        @dump "Buzz"
    else
        @dump n
    end
end

let main ~ do
    for 0 20 fn |i| do
        @dump "fac " i " = " (fac i)
    end

    for 0 63 fn |i| do
        @dump "fib " i " = " (fib i)
    end

    # (4) application-expression
    fn |x| do x + 1 end 41

    # (5) literal-expression
    let void = ()
    let one = hundredEvenNumbers ? "hundredEvenNumbers"
    let truth = true
    let greeting = "Hello, World!"
    let name = one
    let intrinsic = @compiler_directive 13

    let block = do
        let hello = "Hello from local Env!"
        fn |_| do @dump hello end
    end
    # @dump hello
    block ()

    let c1 = counter 1
    let c2 = counter 2

    @dump "c1:"
    c1 1
    c1 1
    c1 1
    @dump "c2:"
    c2 1
    c2 1
    c2 1

    for 2 5000 fn |i| do
        if isPrime i then
            @dump i
        end
    end

    fib >> fac <| 4 ? "fib(fac(4))"

    # FIXME: block-expression + closure = global variable!
    let c3 = counter_
    let c4 = counter_
    @dump "c3:"
    c3 3
    c3 3
    c3 3
    @dump "c4:"
    c4 5
    c4 5
    c4 5

    for 1 100 fizzBuzz

    fib 13 ? "fibonacci 13"

    let luckyNumbers = [
        42,
        69,
        420
    ]
end

