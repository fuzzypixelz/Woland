use std::collections::HashMap;

use polytype::{Type, TypeSchema, Variable};

use crate::ast::*;
use crate::lexer::{Tok, LexicalError};

// NOTE: The type_builder is a temporary HashMap that keeps
// track of type variables and their corresponding variable number
// in polytype. For example `forall a. a -> a` creates an entry
// in the back of type_builder with { "a" : 0 }, this is clear()'d
// once the non-terminal is fully parsed.
grammar<'input>(input: &'input str, type_builder: &mut HashMap<String, usize>);

pub AST: AST = {
    <m: Mod> <ds: Def+> => AST { module: m, defs: ds },
};

Mod: Mod = {
    <is: (Import <Name> Newline)*> => Mod { imports: is }
}

pub Def: Def = {
    <DName>  => Def::Name(<>),
};

DName: DName = {
    Let <n: Name> <ps: Name*> <a: NL<Ann>?> <op: NL<AOP>> <e: Expr> Newline => {
        if ps.is_empty() {
            DName {name: n, ann: a, op, expr: e}
        } else {
            let mut rhs_expr = e;
            // Making lambdas with lambdas, such expressivity!
            let make_lambda = |p, e| Expr::Func { 
                    param: p,
                    expr: Box::new(e),
            };
            for param in ps.into_iter().rev() {
                rhs_expr = make_lambda(param.clone(), rhs_expr)
            }
            DName { name: n, ann: a, op, expr: rhs_expr }
        }
    }
};

Ann: TypeSchema = {
    Colon <TypeSchema> => {
        // The type_build should always be empty before we
        // start parsing a type annotation; it's empty when
        // first created so this is fully guaranteed.
        type_builder.clear();
        <>
    }
};

SimpleMonoType: Type = {
    LParen <MonoType> RParen,
    // NOTE: the convention is that type-variables are lower-case,
    // but constructor names start with an upper-case.
    <v: Name> => Type::Variable(
        // FIXME: Figure out how to do proper error reporting
        // in the parser! (probably by passing in a mut data-type).
        *type_builder.get(&v).unwrap()
    )
}

MonoType: Type = {
    <SimpleMonoType>,
    <n: TypeName> <ps: SimpleMonoType*> => Type::Constructed(
        // TODO: is it better to lear the String or to switch N to String,
        // alltogether? At least in the second case the names will be freed
        // once the we're done with them i.e the typechecker!
        // There is a small hurdle as polytype only implements `Name` for
        // &'static str.
        Box::leak(n.into_boxed_str()),
        ps
    ),
}

// NOTE: this part had to be seperated from the TypeSchema terminal,
// since the .insert(..) wasn't getting executed before attempting
// to parse the reset of the annotation, and so the variables weren't
// present.
TypeQuantifier : Variable = {
    // FIXME: we shouldn't force the poor programmers to type `forall`
    // everytime they need to do polymorphism, oh the horror!
    Forall <v: Name> Dot => {
        // The number of the `v` is picked as the maximum existing
        // type variable PLUS one. Otherwise we put in zero.
        let variable = match type_builder.values().max() {
            None => 0,
            Some(v) => v + 1,
        };
        type_builder.insert(v, variable);
        variable
    }
}

TypeSchema: TypeSchema = {
    <SepList1<MonoType, Arrow>> => TypeSchema::Monotype(Type::from(<>)),
    <v: TypeQuantifier> <t: TypeSchema> =>
        TypeSchema::Polytype {
            variable: v,
            body: Box::new(t),
        }
};

AOP: AssignOp = {
    Equal => AssignOp::Equal,
    Tilde => AssignOp::Tilde
};

Instr: Instr = {
    <DName>           => Instr::Let(<>),
    <Expr>   Newline  => Instr::Compute(<>),
    Ellipsis Newline  => Instr::Ellipsis, 
    Break    Newline  => Instr::Break,
    <Bind>,
    <Assign>,
    NL<Loop> <b: Block> NL<End> => Instr::Loop { body: b },
    // TODO: reintroduce `while` as a macro.
    // It was removed because it causing ambiguity with do ... end
    // blocks; the parser couldn't tell if the block is something
    // to execute or apply to a left function.
    // Being able to write `|x| x` and `|x| do x end` is more
    // important than having builtin while loops for me, and they
    // just compile to loop ... end blocks anyway!
    // NL<While> <c: Expr> NL<Do> <mut b: Block> NL<End> => {
    //     b.insert(0, Instr::Compute(Expr::Branch {
    //         paths: vec![
    //             (c,                vec![Instr::Ellipsis]),
    //             (Expr::Bool(true), vec![Instr::Break])
    //         ]
    //     }));
    //     Instr::Loop { body: b }
    // },
};

Block: Vec<Instr> = {
    <Expr> => vec![Instr::Compute(<>)],
    <Instr+>
};

Intrinsic: Expr = {
    At <n: Name> <es: NApply*>
    => Expr::Intrinsic { name: n, args: es }
};

Bind: Instr = {
    Var <n: Name> <a: NL<Ann>?> <op: NL<AOP>> <e: Expr> Newline
    => Instr::Var {name: n, ann: a, op, expr: e}
};

Assign: Instr = {
    <n: Name> <op: AOP> <e: Expr> Newline
    => Instr::Assign {name: n, op, expr: e}
};

Branch: Expr = {
    If <e: Expr> NL<Then> <b1: Block> 
    <b2: (NL<Elif> <Expr> NL<Then> <Block>)*> 
    <b3: (NL<Else> <Block>)?> End
    => { 
        let b3 = match b3 {
            None    => vec![Instr::Compute(Expr::Void)],
            Some(v) => v
        };
        let mut paths = vec![(e, b1)];
        paths.extend(b2.into_iter());
        paths.push((Expr::Bool(true), b3));
        Expr::Branch { paths }
    }
};

Expr : Expr = {
    Infix,
    Func,
};

Infix: Expr = {
    NInfix,
    <l: Infix> <op: OP> <r: NInfix> => Expr::Apply {
        left: Box::new(Expr::Apply { 
            left:  Box::new(Expr::Name(op)),
            right: Box::new(l)
        }),
        right: Box::new(r)
    },
    Intrinsic,
}

NInfix: Expr = {
    NApply,
    Apply,
};

// Not a function application
NApply: Expr = {
    LParen RParen  => Expr::Void,
    <Boolean>      => Expr::Bool(<>),
    <I64>          => Expr::Int(<>),
    <Name>         => Expr::Name(<>),
    <Str>          => Expr::Str(<>),
    <Char>         => Expr::Char(<>),
    List,
    Array,
    Branch,
    NL<Do> <Block> End => Expr::Block { body: <> },
    LParen <Expr> RParen,
};

Apply: Expr = {
    <l: Apply>  <r: NApply>  => Expr::Apply { left: Box::new(l), right: Box::new(r) },
    <l: NApply> <r: NApply> => Expr::Apply { left: Box::new(l), right: Box::new(r) },
};

List: Expr = {
    NL<LSBrack> <v: SepList<Expr, NL<Comma>>> RSBrack => Expr::List(v)
}

Array: Expr = {
    Hash NL<LSBrack> <v: SepList<Expr, NL<Comma>>> RSBrack => Expr::Array(v)
}

Func: Expr = {
    Pipe <ps: Name+> NL<Pipe> <e: Infix> => {
        let mut lambda = e;
        let make_lambda = |p, e| Expr::Func { 
                param: p,
                expr: Box::new(e),
        };
        for param in ps.into_iter().rev() {
            lambda = make_lambda(param.clone(), lambda)
        }
        lambda
    }
};

I64: i64 = <"Int"> => match <> {
    Tok::IntLiteral(i)  => i,
    _ => panic!("unreacheable")
};

Char: char = <"Char"> => match <> {
    Tok::CharLiteral(c)  => c,
    _ => panic!("unreacheable")
};

Boolean: bool = {
    True  => true,
    False => false
};

TypeName: String = <"TypeName"> => <>.to_string();
Name:     String = {
    <"Name"> => <>.to_string(),
    LParen <OP> RParen
};
OP:       String = <"OP">   => format!("({})", <>).to_string();
Str:      String = <"Str">  => <>.to_string();

NL<T>: T     = <T> Newline?;

SepList<T, S>: Vec<T> = {
    <mut v: (<T> S)*> <e: NL<T>?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

SepList1<T, S>: Vec<T> = {
    <mut v: (<T> S)*> <e: T> => { v.push(e); v }
};

Many2<T>: Vec<T> = {
    <mut v: T+> <e: T> => { v.push(e); v }
};

extern {
    type Location = usize;
    type Error = LexicalError;
    
    enum Tok<'input> {
        "Name"     => Tok::Name(<&'input str>),
        "TypeName" => Tok::TypeName(<&'input str>),
        "OP"       => Tok::Operator(<&'input str>),

        "Int"      => Tok::IntLiteral(i64),
        "Str"      => Tok::StrLiteral(<&'input str>),
        "Char"     => Tok::CharLiteral(char),

        Ellipsis   => Tok::Ellipsis,

        At         => Tok::At,
        // TODO: remove this (?)
        Excl       => Tok::Excl, 
        Dot        => Tok::Dot,

        Let        => Tok::Let,
        Do         => Tok::Do,
        End        => Tok::End,
        Var        => Tok::Var,
        // TODO: replace type with data
        Type       => Tok::Type, 
        Macro      => Tok::Macro,
        Import     => Tok::Import,
        Forall     => Tok::Forall,

        // TODO: r eplace true/false with algebraic data-types
        True       => Tok::True,
        False      => Tok::False,
        If         => Tok::If,
        Then       => Tok::Then,
        Elif       => Tok::Elif,
        Else       => Tok::Else,

        Fn         => Tok::Fn, 

        Loop       => Tok::Loop,
        While      => Tok::While,

        Break      => Tok::Break,

        Colon      => Tok::Colon,
        Arrow      => Tok::Arrow,
        DArrow     => Tok::DArrow,
        Pipe       => Tok::Pipe,
        Comma      => Tok::Comma,
        Equal      => Tok::Equal,
        Tilde      => Tok::Tilde,
        Hash       => Tok::Hash,

        LParen     => Tok::LParen,
        RParen     => Tok::RParen,
        LBrack     => Tok::LBrack,
        RBrack     => Tok::RBrack,
        LSBrack    => Tok::LSBrack,
        RSBrack    => Tok::RSBrack,

        Newline    => Tok::Newline
    }
}
