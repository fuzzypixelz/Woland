use std::collections::HashMap;

use polytype::{Type, TypeSchema, Variable};

use crate::ast::*;
use crate::lexer::Tok;
use crate::error::LexicalError;

// NOTE: The type_builder is a temporary HashMap that keeps
// track of type variables and their corresponding variable number
// in polytype. For example `forall a. a -> a` creates an entry
// in the back of type_builder with { "a" : 0 }, this is clear()'d
// once the non-terminal is fully parsed.
grammar<'input>(input: &'input str, type_builder: &mut HashMap<String, usize>);

pub Item: Item = {
    Definition,
    Attribute,
    DataType,
    Module,
};

Definition: Item = {
    Let <name: Name> <ps: Name*> <ann: NL<Ann>?> NL<Equal> <e: Expr> Newline => {
        if ps.is_empty() {
            DName {name: n, ann: a, op, expr: e}
        } else {
            let mut expr = e;
            for param in ps.into_iter().rev() {
                rhs_expr = Expr::Func { 
                    param,
                    expr: Box::new(rhs_expr),
                };
            }
            Item::Definition { name, ann, expr }
        }
    }
};

Attribute: Item = {
    At LBrack <name: Name> LParen <args: SepList<Expr, Comma>> RParen RBrack Newline
        => Item::Attribute { name, args }
};

DataType: Item = {
    Data <kind: TypeSchema> Newline
        <variants: SepList<Variant, Comma>>
    End => Item::DataType { kind, variants }
};

Variant: (String, Vec<(String, TypeSchema)>) = {
    <TypeName> NL<LBrace> 
        <SepList<Name, Comma>>
    RBrace
};

Module: Item = {
    Mod <name: Name> Newline
        <items: Item*> 
    End => Item::Module { name, items }
};

Ann: TypeSchema = {
    Colon <TypeSchema> => {
        // The type_build should always be empty before we
        // start parsing a type annotation; it's empty when
        // first created so this is fully guaranteed.
        type_builder.clear();
        <>
    }
};

SimpleMonoType: Type = {
    LParen <MonoType> RParen,
    // NOTE: the convention is that type-variables are lower-case,
    // but constructor names start with an upper-case.
    <v: Name> => Type::Variable(
        // FIXME: Figure out how to do proper error reporting
        // in the parser! (probably by passing in a mut data-type).
        *type_builder.get(&v).unwrap()
    )
}

MonoType: Type = {
    SimpleMonoType,
    <n: TypeName> <ps: SimpleMonoType*> => Type::Constructed(
        // TODO: is it better to lear the String or to switch N to String,
        // alltogether? At least in the second case the names will be freed
        // once the we're done with them i.e the typechecker!
        // There is a small hurdle as polytype only implements `Name` for
        // &'static str.
        Box::leak(n.into_boxed_str()),
        ps
    ),
}

// NOTE: this part had to be seperated from the TypeSchema terminal,
// since the .insert(..) wasn't getting executed before attempting
// to parse the reset of the annotation, and so the variables weren't
// present.
TypeQuantifier: Variable = {
    // FIXME: we shouldn't force the poor programmers to type `forall`
    // everytime they need to do polymorphism, oh the horror!
    Forall <v: Name> Dot => {
        // The number of the `v` is picked as the maximum existing
        // type variable PLUS one. Otherwise we put in zero.
        let variable = match type_builder.values().max() {
            None => 0,
            Some(v) => v + 1,
        };
        type_builder.insert(v, variable);
        variable
    }
}

TypeSchema: TypeSchema = {
    SepList1<MonoType, Arrow> => TypeSchema::Monotype(Type::from(<>)),
    <v: TypeQuantifier> <t: TypeSchema> =>
        TypeSchema::Polytype {
            variable: v,
            body: Box::new(t),
        }
};

Stmt: Stmt = {
    Item           => Stmt::Item(<>),
    <Expr> Newline => Stmt::Expr(<>),
};

Expr : Expr = {
    Infix,
    // TODO: See if we can remove the necessary () around |x| do .. end
    // functions by having two seperate terminals, one for "single-line"
    // lambdas and another do "multi-line" lambdas.
    Func,
    Assign,
};

Infix: Expr = {
    NInfix,
    <l: Infix> <op: OP> <r: NInfix> => Expr::Apply {
        left: Box::new(Expr::Apply { 
            left:  Box::new(Expr::Name(op)),
            right: Box::new(l)
        }),
        right: Box::new(r)
    },
};

NInfix: Expr = {
    Apply,
    NApply,
};

NApply: Expr = {
    Ellipsis       => Expr::Ellipsis,
    LParen RParen  => Expr::Void,
    I64            => Expr::Int(<>),
    Boolean        => Expr::Bool(<>),
    Char           => Expr::Char(<>),
    Str            => Expr::Str(<>),
    Name           => Expr::Name(<>),
    Branch,
    Field,
    NL<Do> <Block> End => Expr::Block { body: <> },
    LParen <Expr> RParen,
};

Apply: Expr = {
    <l: Apply>  <r: NApply>  => Expr::Apply { left: Box::new(l), right: Box::new(r) },
    <l: NApply> <r: NApply> => Expr::Apply { left: Box::new(l), right: Box::new(r) },
};

Func: Expr = {
    Pipe <ps: Name+> NL<Pipe> <e: Expr> => {
        let mut lambda = e;
        for param in ps.into_iter().rev() {
            lambda = Expr::Func { 
                param,
                expr: Box::new(lambda),
            };
        }
        lambda
    }
};

Field: Expr = {
    <expr: NApply> Dot <name: Name> => Expr::Field { expr, name }
};

Assign: Expr = {
    <left: Field> Equal <right: Expr> => Expr::Assign { left, right }
};

Block: Vec<Stmt> = {
    Expr    => vec![Stmt:Expr(<>)],
    <Stmt+>
};

Branch: Expr = {
    If <e: Expr> NL<Then> <b1: Block> 
    <b2: (NL<Elif> <Expr> NL<Then> <Block>)*> 
    <b3: (NL<Else> <Block>)?> End
    => { 
        let b3 = match b3 {
            // If the user doesn't provide an else clause
            // we insert one with a `()` expression which
            // forces the entire expression to have type Void.
            None    => vec![Stmt::Compute(Expr::Void)],
            Some(v) => v
        };
        let mut paths = vec![(e, b1)];
        paths.extend(b2.into_iter());
        paths.push((Expr::Bool(true), b3));
        Expr::Branch { paths }
    }
};

List: Expr = {
    NL<LBrack> <v: SepList<Expr, NL<Comma>>> RBrack => Expr::List(v)
};

Array: Expr = {
    Hash NL<LBrack> <v: SepList<Expr, NL<Comma>>> RBrack => Expr::Array(v)
};

I64: i64 = <"Int"> => match <> {
    Tok::IntLiteral(i)  => i,
    _ => unreachable!()
};

Char: char = <"Char"> => match <> {
    Tok::CharLiteral(c)  => c,
    _ => unreachable!()
};

Boolean: bool = {
    True  => true,
    False => false
};

TypeName: String = <"TypeName"> => <>.to_string();
Name:     String = {
    <"Name"> => <>.to_string(),
    LParen <OP> RParen
};
OP:       String = <"OP">   => format!("({})", <>).to_string();
Str:      String = <"Str">  => <>.to_string();

NL<T>: T     = <T> Newline?;

SepList<T, S>: Vec<T> = {
    <mut v: (<T> S)*> <e: NL<T>?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

SepList1<T, S>: Vec<T> = {
    <mut v: (<T> S)*> <e: T> => { v.push(e); v }
};

Many2<T>: Vec<T> = {
    <mut v: T+> <e: T> => { v.push(e); v }
};

extern {
    type Location = usize;
    type Error = LexicalError;
    
    enum Tok<'input> {
        "Name"     => Tok::Name(<&'input str>),
        "TypeName" => Tok::TypeName(<&'input str>),
        "OP"       => Tok::Operator(<&'input str>),

        "Int"      => Tok::IntLiteral(i64),
        "Str"      => Tok::StrLiteral(<&'input str>),
        "Char"     => Tok::CharLiteral(char),

        Ellipsis   => Tok::Ellipsis,

        At         => Tok::At,
        // TODO: remove this (?)
        Excl       => Tok::Excl, 
        Dot        => Tok::Dot,

        Mod        => Tok::Mod,
        Let        => Tok::Let,
        Do         => Tok::Do,
        End        => Tok::End,
        Var        => Tok::Var,
        // TODO: replace type with data
        Data       => Tok::Data, 
        Macro      => Tok::Macro,
        Import     => Tok::Import,
        Forall     => Tok::Forall,

        // TODO: r eplace true/false with algebraic data-types
        True       => Tok::True,
        False      => Tok::False,
        If         => Tok::If,
        Then       => Tok::Then,
        Elif       => Tok::Elif,
        Else       => Tok::Else,

        Fn         => Tok::Fn, 

        Loop       => Tok::Loop,
        While      => Tok::While,

        Break      => Tok::Break,

        Colon      => Tok::Colon,
        Arrow      => Tok::Arrow,
        DArrow     => Tok::DArrow,
        Pipe       => Tok::Pipe,
        Comma      => Tok::Comma,
        Equal      => Tok::Equal,
        Tilde      => Tok::Tilde,
        Hash       => Tok::Hash,

        LParen     => Tok::LParen,
        RParen     => Tok::RParen,
        LBrace     => Tok::LBrace,
        RBrace     => Tok::RBrace,
        LBrack     => Tok::LBrack,
        RBrack     => Tok::RBrack,

        Newline    => Tok::Newline
    }
}
