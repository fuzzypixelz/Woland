use std::cell::RefCell;
use std::rc::Rc;

use rustc_hash::FxHashMap;

use crate::ast::*;
use crate::lexer::{Tok, LexicalError};
use crate::interpreter::Env;

grammar<'input>(input: &'input str, macros: &mut FxHashMap<String, DMacro>);

pub AST: AST = {
    <Def+> => AST { defs: <> },
};

pub Def: Def = {
    <DType>  => Def::Type(<>),
    <DName>  => Def::Name(<>),
    <DMacro> => {
        macros.insert(
            <>.name.to_string(),
            <>.clone()
        );
        Def::Macro(<>)
    }
};

pub DMacro: DMacro = {
    Macro <n: Name> Excl <ps: Name*> Equal NL<Do> <b: Block> NL<End> 
    => DMacro { name: n, params: ps, body: b }
}

MacroCall: Expr = {
    <n : Name> Excl <es: NApply*> => {
        let dmacro = macros.get(&n).unwrap().clone();
        let mut body = Vec::new();
        for (p, e) in dmacro.params.into_iter().zip(es.into_iter()) {
            body.push(Instr::Let(DName {
                name: p,
                // FIXME: this is not ideal
                ann: vec!["Void".to_string()],
                op: AOP::Equal,
                expr: e
            }));
        }
        body.extend(dmacro.body);
        dbg!(&body);
        Expr::Block { body }
    }
}

pub DType: DType = {
    Type <n: Name> <ps: Name*> NL<Equal> <b: TBody>
    => DType { name: n, params: ps, body: b }
};

TBody: Vec<DConstr> = {
    <DConstr> => vec![<>],
    <Many2<DConstr>> NL<End>
};

DConstr: DConstr = {
    <n: Name> <r: Record?> Newline => {
        DConstr { name: n, record: r }
    }
};

Record: Vec<(String, Ann)> = {
    LBrack <SepList1<AName, Comma>> RBrack
};

// Annotated name; no parameters
AName: (String, Ann) = {
    <n: Name> Colon <a: Ann> => (n, a)
};

DName: DName = {
    Let <n: Name> <op: AOP> <e: Expr> Newline
    => DName {name: n, ann: vec!["".to_string()], op, expr: e}
};

Ann: Ann = {
    SepList1<TypeName, Arrow>
};

AOP: AOP = {
    Equal => AOP::Equal,
    Tilde => AOP::Tilde
};

Instr: Instr = {
    <DName>           => Instr::Let(<>),
    <Expr> Newline    => Instr::Compute(<>),
    Ellipsis Newline  => Instr::Ellipsis, 
    Break    Newline  => Instr::Break,
    <Bind>,
    <Assign>,
    NL<Loop> <b: Block> NL<End> => Instr::Loop { body: b },
    NL<While> <c: Expr> NL<Do> <mut b: Block> NL<End> => {
        let not_c = Expr::Apply { 
            left:  Box::new(Expr::Name("not".to_string())),
            right: Box::new(c)
        };
        b.insert(0, Instr::Compute(Expr::Branch {
            paths: vec![
                (not_c,            vec![Instr::Break]),
                (Expr::Bool(true), vec![Instr::Ellipsis])
            ]
        }));
        Instr::Loop { body: b }
    },
};

Block: Vec<Instr> = {
    <Expr> => vec![Instr::Compute(<>)],
    <Instr+>
};

Intrinsic: Expr = {
    At <n: Name> <es: NApply*>
    => Expr::Intrinsic { name: n, args: es }
};

Bind: Instr = {
    Var <n: Name> <op: AOP> <e: Expr> Newline
    => Instr::Var {name: n, ann: vec!["".to_string()], op, expr: e}
};

Assign: Instr = {
    <n: Name> <op: AOP> <e: Expr> Newline
    => Instr::Assign {name: n, op, expr: e}
};

Branch: Expr = {
    If <e: Expr> NL<Then> <b1: Block> <b2: (NL<Else> <Block>)?> End
    => { 
        let b2 = match b2 {
            None    => vec![Instr::Compute(Expr::Void)],
            Some(v) => v
        };
        Expr::Branch { paths: vec![(e, b1), (Expr::Bool(true), b2)] }
    }
};

Expr: Expr = {
    NInfix,
    <l: Expr> <op: OP> <r: NInfix> => Expr::Apply {
        left: Box::new(Expr::Apply { 
            left:  Box::new(Expr::Name(op)),
            right: Box::new(l)
        }),
        right: Box::new(r)
    },
    Intrinsic,
    NL<Do> <Block> End => Expr::Block { body: <> },
    MacroCall,
}

NInfix: Expr = {
    NApply,
    Apply,
};

// Not a function application
NApply: Expr = {
    LParen RParen  => Expr::Void,
    <Boolean>      => Expr::Bool(<>),
    <I64>          => Expr::I64(<>),
    <Name>         => Expr::Name(<>),
    <Str>          => Expr::Str(<>),
    <Func>,
    <Branch>,
    LParen <Expr> RParen,
};

Apply: Expr = {
    <l: Apply> <r: NApply>  => Expr::Apply { left: Box::new(l), right: Box::new(r) },
    <l: NApply> <r: NApply> => Expr::Apply { left: Box::new(l), right: Box::new(r) },
};

Func: Expr = {
    // TODO: bring back type annotations
    // Fn Pipe <an: AName?> Pipe Arrow <mut a: Ann> 
    Fn Pipe <n: Name?> NL<Pipe>
    NL<Do> <b: Block> End => {
        // let (n, t) = match an {
        //     None => ("_".to_string(), "Void".to_string()),
        //     Some((n, t)) => (n, t.first().unwrap().to_owned())
        // };
        // a.insert(0, t);
        let c = Rc::new(RefCell::new(Env::default()));
        Expr::Func { 
            param: n.unwrap_or("_".to_string()),
            body: b, 
            closure: c, 
            ann: vec!["Void".to_string()] 
        }
    }
};

I64: i64 = <"I64"> => match <> {
    Tok::IntLiteral(i)  => i,
    _ => panic!("unreacheable")
};

Boolean: bool = {
    True  => true,
    False => false
};

TypeName: String = <"type"> => <>.to_string();
Name:     String = {
    <"name"> => <>.to_string(),
    LParen <OP> RParen
};
OP:       String = <"OP">   => format!("({})", <>).to_string();
Str:      String = <"Str">  => <>.to_string();

NL<T>: T     = <T> Newline?;

SepList<T, S>: Vec<T> = {
    <mut v: (<T> S)*> <e: T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

SepList1<T, S>: Vec<T> = {
    <mut v: (<T> S)*> <e: T> => { v.push(e); v }
};

Many2<T>: Vec<T> = {
    <mut v: T+> <e: T> => { v.push(e); v }
};

extern {
    type Location = usize;
    type Error = LexicalError;
    
    enum Tok<'input> {
        "name"    => Tok::Name(<&'input str>),
        "type"    => Tok::TypeName(<&'input str>),
        "OP"      => Tok::Operator(<&'input str>),

        "I64"     => Tok::IntLiteral(i64),
        "Str"     => Tok::StrLiteral(<&'input str>),

        Ellipsis  => Tok::Ellipsis,

        At        => Tok::At,
        Excl      => Tok::Excl,
        Dot       => Tok::Dot,

        Let       => Tok::Let,
        Do        => Tok::Do,
        End       => Tok::End,
        Var       => Tok::Var,
        Type      => Tok::Type,
        Macro     => Tok::Macro,

        True      => Tok::True,
        False     => Tok::False,
        If        => Tok::If,
        Then      => Tok::Then,
        Elif      => Tok::Elif,
        Else      => Tok::Else,

        Fn        => Tok::Fn,

        Loop      => Tok::Loop,
        While     => Tok::While,

        Break     => Tok::Break,

        Colon     => Tok::Colon,
        Arrow     => Tok::Arrow,
        Pipe      => Tok::Pipe,
        Comma     => Tok::Comma,
        Equal     => Tok::Equal,
        Tilde     => Tok::Tilde,

        LParen    => Tok::LParen,
        RParen    => Tok::RParen,
        LBrack    => Tok::LBrack,
        RBrack    => Tok::RBrack,
        LSBrack   => Tok::LSBrack,
        RSBrack   => Tok::RSBrack,

        Newline   => Tok::Newline
    }
}
