use std::collections::HashMap;

use polytype::{Type, TypeSchema, Variable};

use crate::ast::*;
use crate::lexer::Tok;
use crate::error::LexicalError;

// NOTE: The type_builder is a temporary HashMap that keeps
// track of type variables and their corresponding variable number
// in polytype. For example `forall a. a -> a` creates an entry
// in the back of type_builder with { "a" : 0 }, this is clear()'d
// once the non-terminal is fully parsed.
grammar<'input>(input: &'input str, type_builder: &mut HashMap<String, usize>);

pub Program: Vec<Item> = Item*;

Item: Item = {
    <attrs: Attr*> <kind: ItemKind> => Item { attrs, kind }
};

Attr: Attr = {
    At LBrack <name: Name> LParen <args: SepList<Expr, Comma>> RParen RBrack Newline
        => Attr { name, args }
};


pub ItemKind: ItemKind = {
    Definition,
    DataType,
    Module,
};

Definition: ItemKind = {
    Let <name: Name> <ann: NL<Ann>?> NL<Equal> <expr: Expr> Newline
        => ItemKind::Definition { name, ann, expr }
};

DataType: ItemKind = {
    Data <schema: TypeSchema> Newline
        <variants: SepList<Variant, NL<Comma>>>
    NL<End> => {
        type_builder.clear();
        ItemKind::DataType { schema, variants }
    }
};

Variant: (String, Vec<(String, TypeSchema)>) = {
    <TypeName> NL<LBrace> 
        <SepList<(<Name> Colon <TypeSchema>), NL<Comma>>>
    RBrace
};

Module: ItemKind = {
    Mod <name: Name> Newline
        <items: Item*> 
    End => ItemKind::Module { name, items }
};

Ann: TypeSchema = {
    Colon <TypeSchema> => {
        // The type_build should always be empty before we
        // start parsing a type annotation; it's empty when
        // first created so this is fully guaranteed.
        type_builder.clear();
        <>
    }
};

SimpleMonoType: Type = {
    LParen <MonoType> RParen,
    // NOTE: the convention is that type-variables are lower-case,
    // but constructor names start with an upper-case.
    <v: Name> => { dbg!(&type_builder, &v); Type::Variable(
        // FIXME: Figure out how to do proper error reporting
        // in the parser! (probably by passing in a mut data-type).
        *type_builder.get(&v).unwrap()
    ) }
}

MonoType: Type = {
    SimpleMonoType,
    <n: TypeName> <ps: SimpleMonoType*> => Type::Constructed(
        // TODO: is it better to lear the String or to switch N to String,
        // alltogether? At least in the second case the names will be freed
        // once the we're done with them i.e the typechecker!
        // There is a small hurdle as polytype only implements `Name` for
        // &'static str.
        Box::leak(n.into_boxed_str()),
        ps
    ),
}

// NOTE: this part had to be seperated from the TypeSchema terminal,
// since the .insert(..) wasn't getting executed before attempting
// to parse the reset of the annotation, and so the variables weren't
// present.
TypeQuantifier: Variable = {
    // FIXME: we shouldn't force the poor programmers to type `forall`
    // everytime they need to do polymorphism, oh the horror!
    Forall <v: Name> Dot => {
        // The number of the `v` is picked as the maximum existing
        // type variable PLUS one. Otherwise we put in zero.
        let variable = match type_builder.values().max() {
            None => 0,
            Some(v) => v + 1,
        };
        type_builder.insert(v, variable);
        variable
    }
}

TypeSchema: TypeSchema = {
    SepList1<MonoType, Arrow> => TypeSchema::Monotype(Type::from(<>)),
    <v: TypeQuantifier> <t: TypeSchema> =>
        TypeSchema::Polytype {
            variable: v,
            body: Box::new(t),
        }
};

Stmt: Stmt = {
    Item           => Stmt::Item(<>),
    <Expr> Newline => Stmt::Expr(<>),
};

Expr: Expr = {
    Infix,
    // TODO: See if we can remove the necessary () around |x| do .. end
    // functions by having two seperate terminals, one for "single-line"
    // lambdas and another do "multi-line" lambdas.
    Lambda,
    Assign,
};

Lambda: Expr = {
    Pipe <ps: Name+> NL<Pipe> <e: Expr> => {
        let mut lambda = e;
        for param in ps.into_iter().rev() {
            lambda = Expr::Lambda {
                param,
                expr: Box::new(lambda),
            };
        }
        lambda
    }
};

Infix: Expr = {
    NInfix,
    <l: Infix> <op: OP> <r: NInfix> => Expr::Apply {
        left: Box::new(Expr::Apply { 
            left: Box::new(Expr::Name(op)),
            right: Box::new(l)
        }),
        right: Box::new(r)
    },
};

NInfix: Expr = {
    Apply,
    NApply,
};
 
NApply: Expr = {
    Void,
    Int,
    Bool,
    Char,
    Str,
    Ident,
    Branch,
    Field,
    NL<Do> <Block> End => Expr::Block { body: <> },
    LParen <Expr> RParen,
};

Void: Expr = {
    LParen RParen => Expr::Void
};

Int: Expr = {
    "Int" => match <> {
        Tok::IntLiteral(i)  => Expr::Int(i),
        _ => unreachable!()
    }
};

Bool: Expr = {
    True  => Expr::Bool(true),
    False => Expr::Bool(false)
};

Char: Expr = {
    "Char" => match <> {
        Tok::CharLiteral(c)  => Expr::Char(c),
        _ => unreachable!()
    }
};

Str: Expr = {
    "Str" => Expr::Str(<>.to_string())
};

Ident: Expr = {
    Name => Expr::Name(<>)
};

Branch: Expr = {
    If <e: Expr> NL<Then> <b1: Block> 
    <b2: (NL<Elif> <Expr> NL<Then> <Block>)*> 
    <b3: (NL<Else> <Block>)?> End
    => { 
        // FIXME: the parser should not arbitrarily insert AST nodes,
        // this should ideally be moved much further down.
        let b3 = match b3 {
            // If the user doesn't provide an else clause
            // we insert one with a `()` expression which
            // forces the entire expression to have type Void.
            None    => vec![Stmt::Expr(Expr::Void)],
            Some(v) => v
        };
        let mut paths = vec![(e, b1)];
        paths.extend(b2.into_iter());
        paths.push((
            Expr::Bool(true),
            b3
        ));
        Expr::Branch { paths }
    }
};

Block: Vec<Stmt> = {
    Expr    => vec![Stmt::Expr(<>)],
    <Stmt+>
};

Apply: Expr = {
    <l: Apply>  <r: NApply> => Expr::Apply { left: Box::new(l), right: Box::new(r) },
    <l: NApply> <r: NApply> => Expr::Apply { left: Box::new(l), right: Box::new(r) },
};

Field: Expr = {
    <expr: NApply> Dot <name: Name>
        => Expr::Field { expr: Box::new(expr), name }
};

Assign: Expr = {
    <left: Field> Equal <right: Expr>
        => Expr::Assign { left: Box::new(left), right: Box::new(right) }
};
 
// List: Expr = {
//     NL<LBrack> <v: SepList<Expr, NL<Comma>>> RBrack => Expr::List(v)
// };

// Array: Expr = {
//     Hash NL<LBrack> <v: SepList<Expr, NL<Comma>>> RBrack => Expr::Array(v)
// };

TypeName: String = <"TypeName"> => <>.to_string();
Name:     String = {
    <"Name"> => <>.to_string(),
    LParen <OP> RParen
};

OP:       String = <"OP">   => format!("({})", <>).to_string();

NL<T>: T     = <T> Newline?;

SepList<T, S>: Vec<T> = {
    <mut v: (<T> S)*> <e: NL<T>?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

SepList1<T, S>: Vec<T> = {
    <mut v: (<T> S)*> <e: T> => { v.push(e); v }
};

Many2<T>: Vec<T> = {
    <mut v: T+> <e: T> => { v.push(e); v }
};

extern {
    type Location = usize;
    type Error = LexicalError;
    
    enum Tok<'input> {
        "Name"     => Tok::Name(<&'input str>),
        "TypeName" => Tok::TypeName(<&'input str>),
        "OP"       => Tok::Operator(<&'input str>),

        "Int"      => Tok::IntLiteral(i64),
        "Str"      => Tok::StrLiteral(<&'input str>),
        "Char"     => Tok::CharLiteral(char),

        Ellipsis   => Tok::Ellipsis,

        At         => Tok::At,
        // TODO: remove this (?)
        Excl       => Tok::Excl, 
        Dot        => Tok::Dot,

        Mod        => Tok::Mod,
        Let        => Tok::Let,
        Do         => Tok::Do,
        End        => Tok::End,
        Var        => Tok::Var,
        // TODO: replace type with data
        Data       => Tok::Data, 
        Macro      => Tok::Macro,
        Import     => Tok::Import,
        Forall     => Tok::Forall,

        // TODO: r eplace true/false with algebraic data-types
        True       => Tok::True,
        False      => Tok::False,
        If         => Tok::If,
        Then       => Tok::Then,
        Elif       => Tok::Elif,
        Else       => Tok::Else,

        Fn         => Tok::Fn, 

        Loop       => Tok::Loop,
        While      => Tok::While,

        Break      => Tok::Break,

        Colon      => Tok::Colon,
        Arrow      => Tok::Arrow,
        DArrow     => Tok::DArrow,
        Pipe       => Tok::Pipe,
        Comma      => Tok::Comma,
        Equal      => Tok::Equal,
        Tilde      => Tok::Tilde,
        Hash       => Tok::Hash,

        LParen     => Tok::LParen,
        RParen     => Tok::RParen,
        LBrace     => Tok::LBrace,
        RBrace     => Tok::RBrace,
        LBrack     => Tok::LBrack,
        RBrack     => Tok::RBrack,

        Newline    => Tok::Newline
    }
}
