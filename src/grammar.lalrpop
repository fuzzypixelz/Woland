use crate::ast::*;
use crate::lexer::{Tok, LexicalError};

grammar<'input>(input: &'input str);

pub AST: AST = {
    <m: Mod> <ds: Def+> => AST { module: m, defs: ds },
};

Mod: Mod = {
    <is: (Import <Name> Newline)*> => Mod { imports: is }
}

pub Def: Def = {
    <DName>  => Def::Name(<>),
};

// Annotated name; no parameters
AName: (String, Ann) = {
    <n: Name> Colon <a: Ann> => (n, a)
};

DName: DName = {
    Let <n: Name> <ps: Name*> <op: AOP> <e: Expr> Newline => {
        if ps.is_empty() {
            DName {name: n, ann: vec!["".to_string()], op, expr: e}
        } else {
            // If the expression is already a block, avoid wrapping
            // it in another one by extracting the Vec<Instr> inside.
            let mut body = match e {
                Expr::Block { body } => body,
                other                => vec![Instr::Compute(other)]
            };
            let make_lambda = |p, b| Expr::Func { 
                    param: p,
                    body: b,
                    ann: vec!["Void".to_string()] 
            };
            let (head, tail) = ps.split_first().unwrap();
            for p in tail.into_iter().rev() {
                body = vec![Instr::Compute(make_lambda(p.clone(), body))]
            }
            DName { name: n, 
                    ann: vec!["".to_string()], 
                    op, 
                    expr: make_lambda(head.clone(), body) 
            }
        }
    }
};

Ann: Ann = {
    SepList1<TypeName, Arrow>
};

AOP: AssignOp = {
    Equal => AssignOp::Equal,
    Tilde => AssignOp::Tilde
};

Instr: Instr = {
    <DName>           => Instr::Let(<>),
    <Expr> Newline    => Instr::Compute(<>),
    Ellipsis Newline  => Instr::Ellipsis, 
    Break    Newline  => Instr::Break,
    <Bind>,
    <Assign>,
    NL<Loop> <b: Block> NL<End> => Instr::Loop { body: b },
    NL<While> <c: Expr> NL<Do> <mut b: Block> NL<End> => {
        // let not_c = Expr::Apply { 
        //     left:  Box::new(Expr::Name("not".to_string())),
        //     right: Box::new(c)
        // };
        b.insert(0, Instr::Compute(Expr::Branch {
            paths: vec![
                (c,                vec![Instr::Ellipsis]),
                (Expr::Bool(true), vec![Instr::Break])
            ]
        }));
        Instr::Loop { body: b }
    },
};

Block: Vec<Instr> = {
    <Expr> => vec![Instr::Compute(<>)],
    <Instr+>
};

Intrinsic: Expr = {
    At <n: Name> <es: NApply*>
    => Expr::Intrinsic { name: n, args: es }
};

Bind: Instr = {
    Var <n: Name> <op: AOP> <e: Expr> Newline
    => Instr::Var {name: n, ann: vec!["".to_string()], op, expr: e}
};

Assign: Instr = {
    <n: Name> <op: AOP> <e: Expr> Newline
    => Instr::Assign {name: n, op, expr: e}
};

// 
Branch: Expr = {
    If <e: Expr> NL<Then> <b1: Block> <b2: (NL<Elif> <Expr> NL<Then> <Block>)*> <b3: (NL<Else> <Block>)?> End
    => { 
        let b3 = match b3 {
            None    => vec![Instr::Compute(Expr::Void)],
            Some(v) => v
        };
        let mut paths = vec![(e, b1)];
        paths.extend(b2.into_iter());
        paths.push((Expr::Bool(true), b3));
        Expr::Branch { paths }
    }
};

Expr: Expr = {
    NInfix,
    <l: Expr> <op: OP> <r: NInfix> => Expr::Apply {
        left: Box::new(Expr::Apply { 
            left:  Box::new(Expr::Name(op)),
            right: Box::new(l)
        }),
        right: Box::new(r)
    },
    Intrinsic,
    NL<Do> <Block> End => Expr::Block { body: <> },
}

NInfix: Expr = {
    NApply,
    Apply,
};

// Not a function application
NApply: Expr = {
    LParen RParen  => Expr::Void,
    <Boolean>      => Expr::Bool(<>),
    <I64>          => Expr::Int(<>),
    <Name>         => Expr::Name(<>),
    <Str>          => Expr::Str(<>),
    <List>,
    <Func>,
    <Branch>,
    LParen <Expr> RParen,
};

Apply: Expr = {
    <l: Apply>  <r: NApply>  => Expr::Apply { left: Box::new(l), right: Box::new(r) },
    <l: NApply> <r: NApply> => Expr::Apply { left: Box::new(l), right: Box::new(r) },
};

List: Expr = {
    NL<LSBrack> <v: SepList<Expr, NL<Comma>>> RSBrack => Expr::List(v.into())
}

Func: Expr = {
    // TODO: bring back type annotations
    // Fn Pipe <an: AName?> Pipe Arrow <mut a: Ann> 
    Fn Pipe <n: Name?> NL<Pipe>
    NL<Do> <b: Block> End => {
        // let (n, t) = match an {
        //     None => ("_".to_string(), "Void".to_string()),
        //     Some((n, t)) => (n, t.first().unwrap().to_owned())
        // };
        // a.insert(0, t);
        Expr::Func { 
            param: n.unwrap_or("_".to_string()),
            body: b, 
            ann: vec!["Void".to_string()] 
        }
    }
};

I64: i64 = <"I64"> => match <> {
    Tok::IntLiteral(i)  => i,
    _ => panic!("unreacheable")
};

Boolean: bool = {
    True  => true,
    False => false
};

TypeName: String = <"type"> => <>.to_string();
Name:     String = {
    <"name"> => <>.to_string(),
    LParen <OP> RParen
};
OP:       String = <"OP">   => format!("({})", <>).to_string();
Str:      String = <"Str">  => <>.to_string();

NL<T>: T     = <T> Newline?;

SepList<T, S>: Vec<T> = {
    <mut v: (<T> S)*> <e: NL<T>?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

SepList1<T, S>: Vec<T> = {
    <mut v: (<T> S)*> <e: T> => { v.push(e); v }
};

Many2<T>: Vec<T> = {
    <mut v: T+> <e: T> => { v.push(e); v }
};

extern {
    type Location = usize;
    type Error = LexicalError;
    
    enum Tok<'input> {
        "name"    => Tok::Name(<&'input str>),
        "type"    => Tok::TypeName(<&'input str>),
        "OP"      => Tok::Operator(<&'input str>),

        "I64"     => Tok::IntLiteral(i64),
        "Str"     => Tok::StrLiteral(<&'input str>),

        Ellipsis  => Tok::Ellipsis,

        At        => Tok::At,
        Excl      => Tok::Excl,
        Dot       => Tok::Dot,

        Let       => Tok::Let,
        Do        => Tok::Do,
        End       => Tok::End,
        Var       => Tok::Var,
        Type      => Tok::Type,
        Macro     => Tok::Macro,
        Import    => Tok::Import,

        True      => Tok::True,
        False     => Tok::False,
        If        => Tok::If,
        Then      => Tok::Then,
        Elif      => Tok::Elif,
        Else      => Tok::Else,

        Fn        => Tok::Fn,

        Loop      => Tok::Loop,
        While     => Tok::While,

        Break     => Tok::Break,

        Colon     => Tok::Colon,
        Arrow     => Tok::Arrow,
        Pipe      => Tok::Pipe,
        Comma     => Tok::Comma,
        Equal     => Tok::Equal,
        Tilde     => Tok::Tilde,

        LParen    => Tok::LParen,
        RParen    => Tok::RParen,
        LBrack    => Tok::LBrack,
        RBrack    => Tok::RBrack,
        LSBrack   => Tok::LSBrack,
        RSBrack   => Tok::RSBrack,

        Newline   => Tok::Newline
    }
}
