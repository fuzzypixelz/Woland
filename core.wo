-- The Woland core library.

-- Infix operator are (always) left-associative,
-- so an expression of the form e1 OP e2 OP e3 is
-- equivalent to (e1 OP e2) OP e3. Partly (mostly)
-- because this is the simplest way to parse them :^)
--: A -> (A -> B) -> B 
let (|>) x f = f x

--: (A -> B) -> A -> B 
let (<|) f x = f x

-- Sequence two functions
--: (A -> B) -> (B -> C) -> A -> C
let (>>) f g x = g (f x)

-- (1) lambda-expression,this defintion expands to:
-- let (+) = fn |x: Int| -> Int -> Int do
--     fn |y: Int| -> Int do
--         @add x y
--     end
-- end
-- The @-things and their args are special expressions
-- whoose meaning is determined by the interpreter.
--: Int -> Int -> Int
let (+) x y = @add x y

--: Int -> Int -> Int
let (-) x y = @sub x y

--: Int -> Int -> Int
let (*) x y = @mul x y

--: Int -> Int -> Int
let (/) x y = @div x y

--: Int -> Int -> Int
let (%) x y = @mod x y

--: A -> A -> Bool
let (==) x y = @cmp x y

-- (2) if-expression
--: Bool -> Bool
let not x = if x then false else true end

--: Bool -> Bool -> Bool
let (||) x y = if x then true else y end

--: Bool -> Bool -> Bool
let (&&) x y = if x then y else false end

--: A -> A -> Bool
let (!=) x y = not (@cmp x y)

--: A -> Str -> A
let (?) e n ~ do
    @dump "[debug] " n " = " e
    e
end

--: A -> A -> Void
let (?=) x y ~ do
    if x != y then
        @dump "[assert] " x " != " y
    end
end

--: Int -> Int -> (A -> B) -> Void
let for s e f = do
    var i = s
    -- this compiles down to the following:
    -- loop
    --   if condition then
    --       ...
    --   else
    --       break
    --   end
    --   # do-block
    -- end
    while i != e do
        f i
        i = i + 1
    end
end

--: A -> [A] -> [A]
let (::) x xs = @cons x xs

--: (B -> A -> B) -> B -> [A] -> B
let foldl f acc xs = do
    if xs == [] then
        acc
    else
        let h = @head xs
        let t = @tail xs
        foldl f (f acc h) t
    end
end

--: (A -> B -> B) -> B -> [A] -> B
let foldr f acc xs = do
    if xs == [] then
        acc
    else
        let h = @head xs
        let t = @tail xs
        f h (foldr f acc t)
    end
end

--: (A -> B) -> [A] -> [B]
let map f xs = do
    let g x acc = f x :: acc
    foldr g [] xs
end

--: (A -> Bool) -> [A] -> [A]
let filter p xs = do
    let f x acc = if p x then
        x :: acc
    else
        acc
    end
    foldr f [] xs
end

--: (A -> B -> C) -> (B -> A -> C)
let flip f x y = f y x

--: A -> B -> A
let const x y = x

--: [A] -> [A]
let reverse xs = foldl (flip (::)) [] xs

--: [A] -> [A] -> [A]
let (^) xs ys = foldr (::) ys xs

--: [[A]] -> [A]
let concat xs = foldr (^) [] xs

--: (A -> [B]) -> [A] -> [B]
let concatMap f xs = map f xs |> concat

--: [A] -> Int
let len xs = foldr (const ((+) 1)) 0 xs

--: [A] -> Bool
let any p xs = do
    let f x acc = p x || acc
    foldr f false xs
end

--: [A] -> Bool
let all p xs = do
    let f x acc = p x && acc
    foldr f true xs
end

--: [A] -> Void
let println x = @dump x

--: Int -> [A]
let drop n xs = do
    if n == 0 then
        xs
    else
        drop (n - 1) (@tail xs)
    end
end

--: Int -> [A]
let take n xs = do
    if n == 0 then
        []
    else
        let h = @head xs
        let t = @tail xs
        h :: take (n - 1) t
    end
end

--: (A -> Bool) -> [A] -> [A]
let takeWhile p xs = do
    let f x acc = if p x then
        x :: acc
    else
        []
    end
    foldr f [] xs
end

--: Void -> Void
let hcf _ = do
    println "Halt and Catch Fire!"
    0 / 0
end

--: Int -> Int -> [Int]
let (..) s e = do
    if s == e then
        []
    else
         s + 1 .. e |> (::) s
    end
end

let tests = do
    map ((+) 1) [1, 2, 3] ?= [2, 3, 4]

    let sum xs = foldr (+) 0 xs
    sum [1, 2, 3] ?= 6

    let even x = x % 2 == 0
    filter even [1, 2, 3, 4] ?= [2, 4]

    reverse [1, 2, 3] ?= [3, 2, 1]

    [1, 2] ^ [3] ?= [1, 2, 3]

    concat [[1], [2], [3]] ?= [1, 2, 3]

    let repeat x y = do
        if y == 0 then
            []
        else
            x :: repeat x (y - 1)
        end
    end
    repeat 0 3 ?= [0, 0, 0]
    concatMap (repeat 1) [1, 2, 3] |> len ?= sum [1, 2, 3]

    any ((==) 3) [1, 2, 3] ?= true
    all ((==) 3) [1, 2, 3] ?= false

    drop 3 (repeat () 10) ?= repeat () 7
    take 3 (repeat () 10) ?= repeat () 3

    1 .. 3 |> println
end
