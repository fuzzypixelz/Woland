-- The Woland core library.

-- Infix operator are (always) left-associative,
-- so an expression of the form e1 OP e2 OP e3 is
-- equivalent to (e1 OP e2) OP e3. Partly (mostly)
-- because this is the simplest way to parse them :^)
--: A -> (A -> B) -> B 
let (|>) x f = f x

--: (A -> B) -> A -> B 
let (<|) f x = f x

-- Sequence two functions
--: (B -> C) -> (A -> B) -> A -> C
let (>>) f g x = f (g x)

-- (1) lambda-expression,this defintion expands to:
-- let (+) = fn |x: Int| -> Int -> Int do
--     fn |y: Int| -> Int do
--         @add x y
--     end
-- end
-- The @-things and their args are special expressions
-- whoose meaning is determined by the interpreter.
--: Int -> Int -> Int
let (+) x y = @add x y

--: Int -> Int -> Int
let (-) x y = @sub x y

--: Int -> Int -> Int
let (*) x y = @mul x y

--: Int -> Int -> Int
let (/) x y = @div x y

--: Int -> Int -> Int
let (%) x y = @mod x y

--: A -> A -> Bool
let (==) x y = @cmp x y

-- (2) if-expression
--: Bool -> Bool
let not x = if x then false else true end

--: Bool -> Bool -> Bool
let (||) x y = if x then true else y end

--: Bool -> Bool -> Bool
let (&&) x y = if x then y else false end

--: A -> A -> Bool
let (!=) x y = not (@cmp x y)

--: A -> Str -> A
let (?) e n ~ do
    @dump "[debug] " n " = " e
    e
end

--: A -> A -> Void
let (=?) x y ~ do
    if x != y then
        @dump "[assert] " x " != " y
    end
end

--: Int -> Int -> (A -> B) -> Void
let for s e f = do
    var i = s
    -- this compiles down to the following:
    -- loop
    --   if condition then
    --       ...
    --   else
    --       break
    --   end
    --   # do-block
    -- end
    while i != e do
        f i
        i = i + 1
    end
end

--: A -> [A] -> [A]
let (::) x xs = @cons x xs

--: (A -> B) -> [A] -> [B]
let map f xs = do
    if xs == [] then
        []
    else
        let h = @head xs
        let t = @tail xs
        f h :: map f t
    end
end

--: (A -> Bool) -> [A] -> [A]
let filter p xs = do
    if xs == [] then
        []
    else
        let h = @head xs
        let t = @tail xs
        if p h then
            h :: filter p t
        else
            filter p t
        end
    end
end

--: (B -> A -> B) -> B -> [A] -> B
let fold f acc xs = do
    if xs == [] then
        acc
    else
        let h = @head xs
        let t = @tail xs
        fold f (f acc h) t
    end
end

let tests = do
    map ((+) 1) [1, 2, 3] =? [2, 3, 4]

    let sum xs = fold (+) 0 xs
    sum [1, 2, 3] =? 6

    let even x = x % 2 == 0
    filter even [1, 2, 3, 4] =? [2, 4]
end
