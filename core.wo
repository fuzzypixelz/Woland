-- The Woland core library.

-- Infix operator are (always) left-associative,
-- so an expression of the form e1 OP e2 OP e3 is
-- equivalent to (e1 OP e2) OP e3. Partly (mostly)
-- because this is the simplest way to parse them :^)
--: a -> (a -> B) -> B 
let (|>) x f = f x

--: (a -> B) -> a -> B 
let (<|) f x = f x

-- Sequence two functions
--: (a -> B) -> (B -> C) -> a -> C
let (>>) f g x = g (f x)

-- (1) lambda-expression,this defintion expands to:
-- let (+) = fn |x: Int| -> Int -> Int do
--     fn |y: Int| -> Int do
--         @add x y
--     end
-- end
-- The @-things and their args are special expressions
-- whoose meaning is determined by the interpreter.
let (+) x y : Int -> Int -> Int
    = @add x y

let (-) x y : Int -> Int -> Int
    = @sub x y

let (*) x y : Int -> Int -> Int
    = @mul x y

let (/) x y : Int -> Int -> Int
    = @div x y

let (%) x y : Int -> Int -> Int
    = @mod x y

let (==) x y : forall a . a -> a -> Bool
    = @cmp x y

-- (2) if-expression
--: Bool -> Bool
let not x = if x then false else true end

--: Bool -> Bool -> Bool
let (||) x y = if x then true else y end

--: Bool -> Bool -> Bool
let (&&) x y = if x then y else false end

--: a -> a -> Bool
let (!=) x y = not (x == y)

let println x : forall a . a -> Void = @dump x

let hcf _ : Void -> Void = do
    println "Halt and Catch Fire!"
    0 / 0
end

let (?) e n : forall a . a -> Str -> a ~ do
    @dump "[debug] " n " = " e
    e
end

let (?=) x y : forall a . a -> a -> Void ~ do
    if x != y then
        @dump "[assert] failed equality check:"
        @dump "[assert] left  = " x
        @dump "[assert] right = " y
        hcf ()
    end
end

--: Int -> Int -> (a -> B) -> Void
let for s e f = do
    var i = s
    loop
        if i == e then
            break
        end
        f i
        i = i + 1
    end
end

let (::) x xs : forall a . List a -> List a -> List a 
    = @cons x xs

let head xs : forall a . List a -> a 
    = @head xs

let tail xs : forall a . List a -> List a 
    = @tail xs

--: (B -> a -> B) -> B -> [a] -> B
let foldl f acc xs = do
    if xs == [] then
        acc
    else
        let h = head xs
        let t = tail xs
        foldl f (f acc h) t
    end
end

--: (a -> B -> B) -> B -> [a] -> B
let foldr f acc xs = do
    if xs == [] then
        acc
    else
        let h = head xs
        let t = tail xs
        f h (foldr f acc t)
    end
end

--: (a -> B) -> [a] -> [B]
let map f xs = do
    let g x acc = f x :: acc
    foldr g [] xs
end

--: (a -> Bool) -> [a] -> [a]
let filter p xs = do
    let f x acc = if p x then
        x :: acc
    else
        acc
    end
    foldr f [] xs
end

--: (a -> B -> C) -> (B -> a -> C)
let flip f x y = f y x

--: a -> B -> a
let const x y = x

--: [a] -> [a]
let reverse xs = foldl (flip (::)) [] xs

--: [a] -> [a] -> [a]
let (^) xs ys = foldr (::) ys xs

--: [[a]] -> [a]
let concat xs = foldr (^) [] xs

--: (a -> [B]) -> [a] -> [B]
let concatMap f xs = map f xs |> concat

--: [a] -> Int
let len xs = foldr (const ((+) 1)) 0 xs

--: [a] -> Bool
let any p xs = do
    let f x acc = p x || acc
    foldr f false xs
end

--: [a] -> Bool
let all p xs = do
    let f x acc = p x && acc
    foldr f true xs
end

let drop n xs = do
    if n == 0 then
        xs
    else
        drop (n - 1) (tail xs)
    end
end

--: Int -> [a]
let take n xs = do
    if n == 0 then
        []
    else
        let h = head xs
        let t = tail xs
        h :: take (n - 1) t
    end
end

--: (a -> Bool) -> [a] -> [a]
let takeWhile p xs = do
    let f x acc = if p x then
        x :: acc
    else
        []
    end
    foldr f [] xs
end

--: Int -> Int -> [Int]
let (..) s e = do
    if s == e then
        []
    else
         s + 1 .. e |> (::) s
    end
end

let tests = do
    map ((+) 1) [1, 2, 3] ?= [2, 3, 4]

    let sum xs = foldr (+) 0 xs
    sum [1, 2, 3] ?= 6

    let even x = x % 2 == 0
    filter even [1, 2, 3, 4] ?= [2, 4]

    reverse [1, 2, 3] ?= [3, 2, 1]

    [1, 2] ^ [3] ?= [1, 2, 3]

    concat [[1], [2], [3]] ?= [1, 2, 3]

    let repeat x y = do
        if y == 0 then
            []
        else
            x :: repeat x (y - 1)
        end
    end
    repeat 0 3 ?= [0, 0, 0]
    concatMap (repeat 1) [1, 2, 3] |> len ?= sum [1, 2, 3]

    any ((==) 3) [1, 2, 3] ?= true
    all ((==) 3) [1, 2, 3] ?= false

    take 3 (1..10) ^ drop 3 (1..10) ?= (1..10)
end
